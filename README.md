# HTTP-Cache
HTTP缓存机制

在HTTP中具有缓存功能的是浏览器缓存。 HTTP缓存作为web性能优化的重要手段，对于从事web开发的朋友有重要的意义。本文将围绕以下几个方面来整理HTTP缓存：  

+ 缓存的规则
+ 缓存的方案
+ 缓存的优点

**缓存的规则**

---
HTTP的缓存属于客户端缓存，后面会提到为什么属于客户端缓存。所以我们认为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js等）。我们将缓存分为强制缓存和协商缓存。  

**强制缓存**  

当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。  

**协商缓存**  

又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效，如果没有失效服务端会返回304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。

`两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。`

**缓存的方案**  

服务器是如何判断缓存是否失效呢？  

浏览器和服务器进行交互的时候会发送一些请求数据和响应数据,称为HTTP报文。包含通用头部，请求头部和响应头部。缓存相关规则信息就包含在HTTP头中。  
`对于强制缓存，服务器响应的header中会用两个字段来表明——Expires和Cache-Control。`  

**Expires**  

Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。  

**Cache-Control**

Cache-Control有很多属性，不同的属性代表的意义也不同。
private：客户端可以缓存
public：客户端和代理服务器都可以缓存
max-age=t：缓存内容将在t秒后失效
no-cache：需要使用协商缓存来验证缓存数据
no-store：所有内容都不会缓存。

**协商缓存**

协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。

**Last-Modified**

Last-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。  
if-Modified-Since:
浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。  

从字面上看，就是说：从某个时间节点算起，是否文件被修改了

1，如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK  
2，如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified

**Etag**

Etag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）  
If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到此报文后发现If-None-Match则与被请求资源的唯一标识进行对比。 

1，不同，说明资源被改动过，则响应整个资源内容，返回状态码200。  

2，相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.

```
Etag 主要为了解决 Last-Modified 无法解决的一些问题:

1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET;
2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)
3、某些服务器不能精确的得到文件的最后修改时间；```